class Solution {
    public long solution(int n) {
        int[] answer = new int[2001];
        answer[1] = 1;
        answer[2] = 2;
        for (int i = 3; i < 2001; i += 1) {
            answer[i] = (answer[i - 2] + answer[i - 1]) % 1234567;
        }
        return answer[n];
    }
}

/*
1. 이해
- 한번에 1칸 또는 2칸을 뛸 수 있다.
- 칸이 총 4개 있을 때,
  1 / 1 / 1 / 1
  1 / 2 / 1
  1 / 1 / 2
  2 / 1 / 1
  2 / 2
  의 5가지 방법으로 맨 끝 칸에 도달할 수 있다.
-> 마지막에 1칸을 뛸 경우 그 앞 칸(n = 3)의 방법에서 +1만 하면 된다. 따라서 answer[i-1]
-> 마지막에 2칸을 뛸 경우 그 앞앞칸(n = 2)의 방법에서 +2만 하면 된다. 따라서 answer[i-2]
- 칸이 총 3개 있을 때. 방법은 3가지다.
  1 / 1 / 1
  1 / 2
  2 / 1
- 칸이 총 2개 있을 때, 방법은 2가지다.
  1 / 1
  2
- 멀리 뛰기에 사용될 칸의 수 n이 주어질 때,
  끝에 도달하는 방법이 몇 가지인지 계산해서
  여기에 1234567을 나눈 나머지를 리턴하는 함수 solution을 완성하라.
  예를 들어, 4가 입력된다면 5를 return하면 된다.
2. 계획
- 이 문제를 잘 보면 f(n) = f(n-1) + f(n-2) 피보나치 수열이라는 것을 알 수 있다.
3. 실행
 */
